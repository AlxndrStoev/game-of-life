{"ast":null,"code":"import { EventEmitter } from '@angular/core';\nimport { interval } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"src/app/services/notification.service\";\nimport * as i2 from \"@angular/common\";\n\nfunction BoardComponent_ng_container_0_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r7 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"div\", 1);\n    i0.ɵɵlistener(\"click\", function BoardComponent_ng_container_0_ng_container_2_Template_div_click_1_listener($event) {\n      i0.ɵɵrestoreView(_r7);\n      const ctx_r6 = i0.ɵɵnextContext(2);\n      return ctx_r6.onClick($event);\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const cell_r4 = ctx.$implicit;\n    const indexRow_r5 = ctx.index;\n    const indexCol_r2 = i0.ɵɵnextContext().index;\n    i0.ɵɵadvance(1);\n    i0.ɵɵclassMap(cell_r4 === 1 ? \"cell alive\" : \"cell dead\");\n    i0.ɵɵattribute(\"data-row\", indexRow_r5)(\"data-col\", indexCol_r2);\n  }\n}\n\nfunction BoardComponent_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"div\");\n    i0.ɵɵtemplate(2, BoardComponent_ng_container_0_ng_container_2_Template, 2, 4, \"ng-container\", 0);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const col_r1 = ctx.$implicit;\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngForOf\", col_r1)(\"ngForTrackBy\", ctx_r0.trackBy);\n  }\n}\n\nexport let BoardComponent = /*#__PURE__*/(() => {\n  class BoardComponent {\n    constructor(notificationService, cdr) {\n      this.notificationService = notificationService;\n      this.cdr = cdr;\n      this.evolving = new EventEmitter();\n      this.hasLiveCells = new EventEmitter();\n    }\n\n    ngOnChanges() {\n      this.gridSize = this.gridSize;\n      this.grid = new Array(this.gridSize);\n      this.nextGeneration = new Array(this.gridSize);\n\n      for (let i = 0; i < this.grid.length; i++) {\n        this.grid[i] = new Array(this.gridSize);\n        this.nextGeneration[i] = new Array(this.gridSize);\n      }\n\n      this.reset();\n    }\n\n    trackBy(index) {\n      return index;\n    }\n\n    trackByCell(rowIndex, colIndex) {\n      return `${rowIndex}-${colIndex}`;\n    }\n\n    emitLiveCells() {\n      const hasAny = this.grid.some(row => row.some(cell => cell === 1));\n      this.hasLiveCells.emit(hasAny);\n    }\n\n    reset() {\n      var _a;\n\n      this.resetGrid();\n      this.evolving.emit(false);\n      (_a = this.subscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();\n      this.emitLiveCells();\n    }\n\n    resetGrid() {\n      for (let row = 0; row < this.grid.length; row++) {\n        for (let col = 0; col < this.grid[row].length; col++) {\n          this.grid[row][col] = 0;\n          this.nextGeneration[row][col] = 0;\n        }\n      }\n    }\n\n    randomize() {\n      // Adjust density based on grid size for better performance\n      const densityFactor = Math.max(0.12, 0.6 * Math.exp(-this.gridSize / 50));\n\n      for (let row = 0; row < this.grid.length; row++) {\n        for (let col = 0; col < this.grid[row].length; col++) {\n          this.grid[row][col] = Math.random() < densityFactor ? 1 : 0;\n        }\n      }\n\n      this.cdr.markForCheck();\n      this.emitLiveCells();\n    }\n\n    next() {\n      this.evolve();\n      this.evolving.emit(false);\n    }\n\n    auto() {\n      this.subscription = interval(125).subscribe(() => this.evolve());\n    }\n\n    pause() {\n      var _a;\n\n      (_a = this.subscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();\n      this.evolving.emit(false);\n    }\n\n    evolve() {\n      var _a;\n\n      this.evolving.emit(true);\n\n      for (let row = 0; row < this.grid.length; row++) {\n        for (let col = 0; col < this.grid[row].length; col++) {\n          const cell = this.grid[row][col];\n          const neighbours = [];\n          let aliveNeighbours = null; // Collect neighbours:\n\n          if (row === 0 || col === 0 || row === this.grid.length - 1 || col === this.grid.length - 1) {\n            // Means we're in the one of four side walls of the matrix.\n            if (row === 0 && col === 0) {\n              // Top left corner, the neighbours are the ones on the right, on the bottom right diagonal and on the bottom.\n              neighbours.push(this.grid[row][col + 1], this.grid[row + 1][col], this.grid[row + 1][col + 1]);\n            } else if (row === 0 && col === this.grid.length - 1) {\n              // Top right corner, the neighbours are the ones on the left, on the bottom left diagonal and on the bottom.\n              neighbours.push(this.grid[row][col - 1], this.grid[row + 1][col - 1], this.grid[row + 1][col]);\n            } else if (row === this.grid.length - 1 && col === 0) {\n              // Bottom left corner, the neighbours are the ones on the top, on the top right diagonal and on the right.\n              neighbours.push(this.grid[row - 1][col], this.grid[row - 1][col + 1], this.grid[row][col + 1]);\n            } else if (row === this.grid.length - 1 && col === this.grid.length - 1) {\n              // Bottom right corner, the neighbours are the ones on the left, on the top left diagonal and on the top.\n              neighbours.push(this.grid[row][col - 1], this.grid[row - 1][col - 1], this.grid[row - 1][col]);\n            } else if (col === 0 && row < this.grid.length - 1) {\n              // Left wall, the neighbours are the ones on the top, on the top right diagonal, on the right, on the bottom right diagonal and on the bottom.\n              neighbours.push(this.grid[row - 1][col], this.grid[row - 1][col + 1], this.grid[row][col + 1], this.grid[row + 1][col + 1], this.grid[row + 1][col]);\n            } else if (row === 0 && col < this.grid.length - 1) {\n              // Top wall, the neighbours are the ones on the left, on the bottom left diagonal, on the bottom, on the bottom right diagonal and on the right.\n              neighbours.push(this.grid[row][col - 1], this.grid[row + 1][col - 1], this.grid[row + 1][col], this.grid[row + 1][col + 1], this.grid[row][col + 1]);\n            } else if (col === this.grid.length - 1 && row < this.grid.length - 1) {\n              // Right wall, the neighbours are the ones on the top, on the top left diagonal, on the left, on the bottom left diagonal and on the bottom.\n              neighbours.push(this.grid[row - 1][col], this.grid[row - 1][col - 1], this.grid[row][col - 1], this.grid[row + 1][col - 1], this.grid[row + 1][col]);\n            } else if (row === this.grid.length - 1 && col < this.grid.length - 1) {\n              // Bottom wall, the neighbours are the ones on the left, on the top left diagonal, on the top, on the top right diagonal and on the right.\n              neighbours.push(this.grid[row][col - 1], this.grid[row - 1][col - 1], this.grid[row - 1][col], this.grid[row - 1][col + 1], this.grid[row][col + 1]);\n            }\n          } else {\n            // Means we have eight neighbours from all sides.\n            // The available neighbours are the ones on the left, on the top left diagonal, on the top, on the top right diagonal, on the right, on the bottom right diagonal, on the bottom and on the bottom left diagonal.\n            neighbours.push(this.grid[row][col - 1], this.grid[row - 1][col - 1], this.grid[row - 1][col], this.grid[row - 1][col + 1], this.grid[row][col + 1], this.grid[row + 1][col + 1], this.grid[row + 1][col], this.grid[row + 1][col - 1]);\n          } // Count alive neighbours\n\n\n          aliveNeighbours = neighbours.filter(Boolean).length; // Validate evolution conditions and evolve.\n          // Either way we should not overwrite the current cell within the current generation as the next evolution won't be correct.\n          // If alive:\n\n          if (cell) {\n            // Any live cell with two or three live neighbours survives.\n            // All other live cells die in the next generation. Similarly, all other dead cells stay dead.\n            this.nextGeneration[row][col] = aliveNeighbours === 2 || aliveNeighbours === 3 ? 1 : 0;\n          } // If dead:\n          else {\n            // Any dead cell with three live neighbours becomes a live cell.\n            this.nextGeneration[row][col] = aliveNeighbours === 3 ? 1 : 0;\n          }\n        }\n      } // Efficient array copy using map\n\n\n      this.grid = this.nextGeneration.map(row => [...row]);\n\n      if (this.previousGeneration && this.endEvolution()) {\n        this.notificationService.info('The evolution came to an end.');\n        (_a = this.subscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();\n        this.evolving.emit(false);\n      } // Efficient array copy using map\n\n\n      this.previousGeneration = this.nextGeneration.map(row => [...row]);\n      this.cdr.markForCheck();\n      this.emitLiveCells();\n    }\n\n    onClick(e) {\n      const cell = e.target;\n      const row = Number(cell.getAttribute('data-row'));\n      const col = Number(cell.getAttribute('data-col'));\n      this.grid[col][row] = this.grid[col][row] === 0 ? 1 : 0;\n      this.cdr.markForCheck();\n      this.emitLiveCells(); // console.table(this.grid);\n    }\n\n    endEvolution() {\n      if (!this.previousGeneration) return false;\n\n      for (let row = 0; row < this.grid.length; row++) {\n        for (let col = 0; col < this.grid[row].length; col++) {\n          if (this.previousGeneration[row][col] !== this.nextGeneration[row][col]) {\n            return false;\n          }\n        }\n      }\n\n      return true;\n    }\n\n  }\n\n  BoardComponent.ɵfac = function BoardComponent_Factory(t) {\n    return new (t || BoardComponent)(i0.ɵɵdirectiveInject(i1.NotificationService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  };\n\n  BoardComponent.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n    type: BoardComponent,\n    selectors: [[\"app-board\"]],\n    inputs: {\n      gridSize: \"gridSize\"\n    },\n    outputs: {\n      evolving: \"evolving\",\n      hasLiveCells: \"hasLiveCells\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature],\n    decls: 1,\n    vars: 2,\n    consts: [[4, \"ngFor\", \"ngForOf\", \"ngForTrackBy\"], [3, \"click\"]],\n    template: function BoardComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, BoardComponent_ng_container_0_Template, 3, 2, \"ng-container\", 0);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngForOf\", ctx.grid)(\"ngForTrackBy\", ctx.trackBy);\n      }\n    },\n    directives: [i2.NgForOf],\n    styles: [\".cell[_ngcontent-%COMP%]{height:.5rem;min-width:.5rem;display:table-cell;border:.5px solid black;contain:strict;transition:background-color 75ms}.cell.alive[_ngcontent-%COMP%]{background:white}.cell.dead[_ngcontent-%COMP%]{background:#1d2024}.cell.dead[_ngcontent-%COMP%]:hover{background:#4e565e}.cell[_ngcontent-%COMP%]:hover{cursor:pointer}\"],\n    changeDetection: 0\n  });\n  return BoardComponent;\n})();","map":null,"metadata":{},"sourceType":"module"}